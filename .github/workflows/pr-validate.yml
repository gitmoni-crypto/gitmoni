name: PR Validator

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches: [transactions]
    paths:
      - 'data/txs/**.json'

permissions:
  contents: read
  pull-requests: write

concurrency:
  group: user-${{ github.actor }}
  cancel-in-progress: false

jobs:
  validate:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout base (target branch)
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.base.sha }}
          path: base

      - name: Checkout head (PR branch)
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          path: head

      - name: Diff and sanity checks
        id: diff
        run: |
          set -e
          cd head
          git fetch --no-tags origin ${{ github.event.pull_request.base.ref }}:basebranch
          git diff --name-status basebranch...HEAD > ../changed.txt
          cat ../changed.txt

          ADDED=$(awk '$1=="A"{print $2}' ../changed.txt | tr '\n' ' ' || true)
          echo "added=$ADDED" >> $GITHUB_OUTPUT

          COUNT=$(echo "$ADDED" | tr ' ' '\n' | grep -E '^data/txs/.+\.json$' | wc -l)
          if [ "$COUNT" != "1" ]; then
            echo "::error::Exactly one new .json under data/txs/ is required"
            exit 1
          fi

          BAD=$(awk '$1!="A"{print $2}' ../changed.txt | tr -d '\n')
          if [ -n "$BAD" ]; then
            echo "::error::Only additions are allowed (append-only ledger)"
            exit 1
          fi

      - name: Validate transaction
        id: validate_tx
        env:
          PR_ACTOR: ${{ github.actor }}
          ADDED: ${{ steps.diff.outputs.added }}
        run: |
          set -e

          node -e '
          import fs from "fs";
          import path from "path";

          const baseTxDir = "base/data/txs";
          const addedList = (process.env.ADDED || "").trim().split(/\s+/).filter(Boolean);
          const added = addedList.find(f => /^data\/txs\/.+\.json$/.test(f));
          if (!added) { console.error("ERR: could not locate added data/txs/*.json"); process.exit(1); }

          const tx = JSON.parse(fs.readFileSync(path.join("head", added), "utf8"));
          const bad = (m) => { console.error("ERR:", m); process.exit(1); };

          if (!tx.txid || !tx.from || !tx.to || typeof tx.amount !== "number" || typeof tx.nonce !== "number") {
            bad("missing fields: required {txid, from, to, amount:number, nonce:number}");
          }
          if (!/^gh:[a-z0-9-]+$/i.test(tx.from) || !/^gh:[a-z0-9-]+$/i.test(tx.to)) {
            bad("from/to must be in form gh:USERNAME");
          }
          if (tx.amount <= 0) bad("amount must be > 0");

          const actor = "gh:" + process.env.PR_ACTOR;
          if (tx.from !== actor) bad(`from=${tx.from} must match PR actor=${actor}`);

          const bal = Object.create(null);
          const nonce = Object.create(null);
          const apply = (t) => {
            bal[t.from]   = (bal[t.from]   || 0) - Number(t.amount);
            bal[t.to]     = (bal[t.to]     || 0) + Number(t.amount);
            nonce[t.from] = (nonce[t.from] || 0) + 1;
          };

          if (fs.existsSync(baseTxDir)) {
            const files = fs.readdirSync(baseTxDir).filter(f => f.endsWith(".json")).sort();
            for (const f of files) {
              try {
                const t = JSON.parse(fs.readFileSync(path.join(baseTxDir, f), "utf8"));
                if (t && t.from && t.to && typeof t.amount === "number") apply(t);
              } catch { console.error("WARN: skipping invalid file", f); }
            }
          }

          const expectedNonce = nonce[tx.from] || 0;
          const fromBal = bal[tx.from] || 0;

          console.log(`EXPECTED_NONCE=${expectedNonce}`);
          console.log(`FROM_BALANCE=${fromBal}`);

          if (tx.nonce !== expectedNonce) bad(`nonce=${tx.nonce} expected=${expectedNonce}`);
          if (fromBal < tx.amount) bad(`insufficient balance: have=${fromBal} need=${tx.amount}`);

          console.log("OK: valid tx");
          '

      - name: Comment expected nonce on failure
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const body = [
              `❌ Validation failed.`,
              `- "from" must match your GitHub login (gh:${context.actor}).`,
              `- Your next nonce should equal your prior outgoing tx count.`,
              `- If you opened multiple PRs, merge the earliest first or bump nonce.`,
            ].join("\n");
            await github.rest.issues.createComment({
              ...context.repo,
              issue_number: context.issue.number,
              body
            });

      - name: Enable auto-merge (squash)
        if: success()
        uses: peter-evans/enable-pull-request-automerge@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          merge-method: squash

      - name: Auto-merge now (squash)
        if: success()
        uses: peter-evans/merge-pull-request@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          merge-method: squash
