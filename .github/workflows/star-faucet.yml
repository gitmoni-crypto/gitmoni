name: Star Faucet (every 10m)

on:
  schedule:
    - cron: "*/10 * * * *"   # every 10 minutes (UTC)
  workflow_dispatch: {}

permissions:
  contents: read
  contents: write

jobs:
  faucet:
    runs-on: ubuntu-latest
    env:
      OWNER: gitmoni-crypto
      REPO:  gitmoni
      TX_BRANCH: transactions
      FAUCET_ADDR: gh:system
      # grant for rank #1
      G1: "1618033989"
      # comma-separated GitHub logins to skip (lowercase). Include owner + bots.
      EXCLUDE_LOGINS: "github-actions[bot],dummyusername,badguy123"

    steps:
      - name: Checkout transactions
        uses: actions/checkout@v4
        with:
          ref: ${{ env.TX_BRANCH }}
          path: tx

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Build faucet txs for new stargazers
        env:
          STARGAZER_TOKEN: ${{ secrets.STARGAZER_TOKEN }}
        run: |
          set -euo pipefail
          cd tx
          mkdir -p data/txs

          node - <<'JS'
          import fs from 'fs';
          import path from 'path';
          
          console.log('=== DEBUG: Script started (NEW VERSION v2) ===');
          console.log(`Environment check:`);
          console.log(`- OWNER: ${process.env.OWNER}`);
          console.log(`- REPO: ${process.env.REPO}`);
          console.log(`- GITHUB_TOKEN present: ${!!process.env.GITHUB_TOKEN}`);
          console.log(`- STARGAZER_TOKEN present: ${!!process.env.STARGAZER_TOKEN}`);
          console.log('=== Starting main logic ===');

          const OWNER   = process.env.OWNER;
          const REPO    = process.env.REPO;
          const G1      = BigInt(process.env.G1 || "1618033989");
          const FAUCET  = process.env.FAUCET_ADDR || "gh:system";
          const EXCLUDE = new Set(
            (process.env.EXCLUDE_LOGINS || '').split(',')
              .map(s => s.trim().toLowerCase())
              .filter(Boolean)
          );
          
          console.log(`Exclude list: ${Array.from(EXCLUDE).join(', ')}`);
          console.log(`GitHub token present: ${!!process.env.GITHUB_TOKEN}`);
          console.log(`Stargazer token present: ${!!process.env.STARGAZER_TOKEN}`);
          console.log(`Using token: ${process.env.STARGAZER_TOKEN ? 'STARGAZER_TOKEN' : 'GITHUB_TOKEN'}`);

          // Test API access first
          console.log('=== Testing API access ===');
          const testUrl = `https://api.github.com/repos/${OWNER}/${REPO}`;
          console.log(`Testing basic repo access: ${testUrl}`);
          try {
            const testResponse = await fetch(testUrl, {
              headers: {
                'Authorization': `Bearer ${process.env.STARGAZER_TOKEN || process.env.GITHUB_TOKEN}`,
                'Accept': 'application/vnd.github+json'
              }
            });
            console.log(`Test response: ${testResponse.status} ${testResponse.statusText}`);
            if (testResponse.ok) {
              const repoData = await testResponse.json();
              console.log(`Repo name: ${repoData.name}, Stars: ${repoData.stargazers_count}`);
            } else {
              const errorText = await testResponse.text();
              console.log(`Test error: ${errorText}`);
            }
          } catch (error) {
            console.log(`Test fetch error: ${error.message}`);
          }

          // --- GitHub fetch helpers (Node 20 has global fetch)
          async function listStargazersChrono() {
            const out = [];
            let page = 1;
            while (true) {
              const url = `https://api.github.com/repos/${OWNER}/${REPO}/stargazers?per_page=100&page=${page}`;
              console.log(`Fetching page ${page}: ${url}`);
              
              const r = await fetch(url, {
                headers: {
                  'Authorization': `Bearer ${process.env.STARGAZER_TOKEN || process.env.GITHUB_TOKEN}`,
                  'Accept': 'application/vnd.github.star+json'
                }
              });
              
              console.log(`Response status: ${r.status} ${r.statusText}`);
              
              if (!r.ok) {
                console.error(`Failed to fetch stargazers: ${r.status} ${r.statusText}`);
                const errorText = await r.text();
                console.error(`Error response: ${errorText}`);
                break;
              }
              
              const data = await r.json();
              console.log(`Received ${data.length} stargazers on page ${page}`);
              
              if (!Array.isArray(data) || data.length === 0) break;
              
              for (const s of data) {
                const login = (s?.user?.login || '').toLowerCase();
                console.log(`Processing stargazer: ${login} (excluded: ${EXCLUDE.has(login)})`);
                if (!login || EXCLUDE.has(login)) {
                  console.log(`Skipping ${login} - in exclude list or no login`);
                  continue; // skip owner/bots
                }
                out.push({ login, starred_at: s.starred_at });
              }
              page++;
            }
            out.sort((a,b)=> new Date(a.starred_at) - new Date(b.starred_at));
            return out;
          }

          // Scan existing ledger for: (a) recipients already paid by faucet; (b) faucet nonce
          function loadPaidAndFaucetNonce() {
            const txDir = 'data/txs';
            const files = fs.existsSync(txDir) ? fs.readdirSync(txDir).filter(f => f.endsWith('.json')) : [];
            const paid = new Set();
            let faucetNonce = 0;

            for (const f of files.sort()) {
              try {
                const t = JSON.parse(fs.readFileSync(path.join(txDir, f), 'utf8'));
                if (!t || typeof t !== 'object') continue;
                if (t.from === FAUCET) {
                  faucetNonce++;
                  if (typeof t.memo === 'string' && t.memo.startsWith('star:rank=')) {
                    paid.add(t.to); // mark recipient as paid
                  }
                }
              } catch { /* ignore corrupt */ }
            }
            return { paid, faucetNonce };
          }

          const grantForRank = (rank) => (G1 / BigInt(rank)); // floor

          function buildTxFile({from, to, amount, nonce, rank}) {
            const ts = Date.now();
            const iso = new Date(ts).toISOString().replace(/\.\d{3}Z/,'Z');
            const txid = `${iso}-${from}->${to}-${amount}`;
            const tx = { txid, from, to, amount: Number(amount), nonce, ts, memo: `star:rank=${rank}` };
            const file = `data/txs/${iso.replace(/[-:]/g,'')}-${from.replace(':','_')}-to-${to.replace(':','_')}-${amount}.json`;
            return { tx, file };
          }

          // LOGGING: Start main logic
          console.log('--- Faucet Workflow: Logging Stargazer and Payment Info ---');

          const { paid, faucetNonce } = loadPaidAndFaucetNonce();
          console.log(`Already paid addresses (${paid.size}):`, Array.from(paid));
          const stars = await listStargazersChrono();
          console.log(`Fetched ${stars.length} stargazers:`, stars.map(s => s.login));

          // Determine unpaid stargazers with their rank (1-based by time)
          const unpaid = [];
          for (let i = 0; i < stars.length; i++) {
            const login = stars[i].login;                    // already lowercased
            const addr  = `gh:${login}`;
            if (paid.has(addr)) {
              console.log(`Skipping ${login} (already paid)`);
              continue; // idempotent
            }
            const rank  = i + 1;
            const amt   = grantForRank(rank);
            if (amt > 0n) unpaid.push({ addr, rank, amt, login });
          }

          if (unpaid.length === 0) {
            console.log('No new stargazers to pay.');
            process.exit(0);
          }

          let nonce = faucetNonce;
          for (const u of unpaid) {
            nonce += 1;
            const { tx, file } = buildTxFile({
              from: FAUCET, to: u.addr, amount: u.amt, nonce, rank: u.rank
            });
            fs.writeFileSync(file, JSON.stringify(tx, null, 2));
            console.log(`Created ${file} :: to=${tx.to} login=${u.login} rank=${u.rank} amount=${tx.amount} nonce=${nonce}`);
          }
          JS

      - name: Push to transactions (via PAT)
        run: |
          cd tx
          git config user.name  "<your-gh-username>"
          git config user.email "<your-gh-email>"
          git add data/txs/*.json
          git commit -m "Faucet: star grants (scheduled)" || exit 0
          git push https://x-access-token:${{ secrets.PUSH_TOKEN }}@github.com/gitmoni-crypto/gitmoni.git HEAD:${{ env.TX_BRANCH }}